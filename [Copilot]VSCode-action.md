>[!note]
> It's generated by Github Copilot.

# VSCode action

VSCode 支持通过定义一个 Action 来实现一些操作，比如在编辑器中打开一个文件，或者在终端中执行一个命令。下面是一个简单的例子，演示如何在 VSCode 中定义一个 Action。

VSCode 提供一个抽象类 Action2 让用户通过简单的描述实现一个 action。

```typescript
export abstract class Action2 {
	constructor(readonly desc: Readonly<IAction2Options>) { }
	abstract run(accessor: ServicesAccessor, ...args: any[]): void;
}
```

一个简单的 Action 可以如下定义：

```typescript
class ToggleChatAction extends Action2 {
    constructor() {
        super({
            id: TOGGLE_CHAT_ACTION_ID,
            title: localize2('toggleChat', "Toggle Chat"),
            category: CHAT_CATEGORY
        });
    }

    async run(accessor: ServicesAccessor) {...}
}
```

只需要将 action 的相关描述信息传入构造函数即可。

## 描述信息定义

首先区分 `f1` 是 `true` 和 `false` 的情况。

- **f1**：用以表示当前命令是否注册到 command palette 中
- **id**：命令的唯一标识符
- **title**：命令的标题，如果 f1 是 true 的话，title 不允许是 string
- **icon**：命令的图标
- **category**：命令的分类，如果 f1 是 true 的话，category 不允许是 string
- **menu**：命令的菜单
- **keybinding**：命令的快捷键
- **precondition**：命令的前置条件


## run 

run 函数是当 action 触发的时候会执行的函数，其参数如下

- accessor：访问器，以确保 action 可以获取到 services
- args：传入的参数，在执行 action 的时候可以传入参数


## registerAction2

在定义上述一个 action 后，通过全局的 registerAction2 方法进行注册。

```typescript

export function registerAction2(ctor: { new(): Action2 }): IDisposable {
    ...
	const action = new ctor();
	const { f1, menu, keybinding, ...command } = action.desc;
    ...

	// command
	disposables.push(CommandsRegistry.registerCommand({
		id: command.id,
		handler: (accessor, ...args) => action.run(accessor, ...args),
		metadata: command.metadata ?? { description: action.desc.title }
	}));

    // 如果有 menu 则表示这个命令还需要往菜单中注册
	if (Array.isArray(menu)) {...} else if (menu) {...}
    // 如果 f1 是 true 则还需要往 command palette 注册
	if (f1) {...}

    // 如果有 keybinding 则表示当前 action 支持快捷键触发
	if (Array.isArray(keybinding)) {...} else if (keybinding) {...}
    ...
}
```