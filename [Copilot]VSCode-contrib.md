>[!note]
> It's generated by Github Copilot.

# VSCode Contrib

在 VS Code 中，`contrib` 是指扩展工作台功能的模块或组件。这些模块通常通过实现特定的接口（如 `IWorkbenchContribution`）来注册功能，并在特定的生命周期阶段（如 `LifecyclePhase.Restored`）被加载和初始化。

## 目录
1. [什么是 `contrib`](#什么是-contrib)
2. [`contrib` 的作用](#contrib-的作用)
3. [`contrib` 的实现](#contrib-的实现)
4. [`contrib` 的注册](#contrib-的注册)
5. [总结](#总结)

## 什么是 `contrib`

`contrib` 是 VS Code 中用于扩展工作台功能的模块或组件。通过实现特定接口，这些模块可以在不同的生命周期阶段被加载，从而增强 VS Code 的功能。

## `contrib` 的作用

1. **扩展功能**：`contrib` 模块用于扩展 VS Code 的核心功能。例如，`SaveParticipantsContribution` 是一个 `contrib` 模块，它扩展了文件保存的行为，允许在保存时执行特定操作（如修剪空白、格式化代码等）。
2. **模块化设计**：通过 `contrib`，VS Code 的功能被模块化，便于维护和扩展。每个 `contrib` 模块专注于一个特定的功能领域。
3. **生命周期管理**：`contrib` 模块可以在特定的生命周期阶段被加载（如启动、恢复、关闭等），从而优化性能和用户体验。

## `contrib` 的实现

以下以 `SaveParticipantsContribution` 为例，说明 `contrib` 的实现方式。在 VS Code 中，保存文件时可以执行一些增强功能（如修剪空白）。这些功能通过 `SaveParticipantsContribution` 实现。

```typescript
export interface IWorkbenchContribution {
	// Marker Interface
}

export class SaveParticipantsContribution extends Disposable implements IWorkbenchContribution {

	constructor(
		@IInstantiationService private readonly instantiationService: IInstantiationService,
		@ITextFileService private readonly textFileService: ITextFileService
	) {
		super();

		this.registerSaveParticipants();
	}

	private registerSaveParticipants(): void {
		this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(TrimWhitespaceParticipant)));
		this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(CodeActionOnSaveParticipant)));
		this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(FormatOnSaveParticipant)));
		this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(FinalNewLineParticipant)));
		this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(TrimFinalNewLinesParticipant)));
	}
}
```

首先，需要实现 `IWorkbenchContribution` 接口，这是一个标记接口，表示该类是一个工作台贡献者。在构造函数中，通过 `registerSaveParticipants` 方法注册保存参与者（`SaveParticipant`）。这些参与者会在文件保存时被调用，执行特定操作。

每个保存参与者的实现如下：

```typescript
export interface ITextFileSaveParticipant {

	/**
	 * The ordinal number which determines the order of participation.
	 * Lower values mean to participant sooner
	 */
	readonly ordinal?: number;

	/**
	 * Participate in a save of a model. Allows to change the model
	 * before it is being saved to disk.
	 */
	participate(...): Promise<void>;
}

export class TrimWhitespaceParticipant implements ITextFileSaveParticipant {
    ...
	async participate(model: ITextFileEditorModel, context: ITextFileSaveParticipantContext): Promise<void> {
        ...
		const trimTrailingWhitespaceOption = this.configurationService.getValue<boolean>('files.trimTrailingWhitespace', { overrideIdentifier: model.textEditorModel.getLanguageId(), resource: model.resource });
        ...
		if (trimTrailingWhitespaceOption) {
			this.doTrimTrailingWhitespace(model.textEditorModel, context.reason === SaveReason.AUTO, trimInRegexAndStrings);
		}
	}
    ...
}
```

`ITextFileSaveParticipant` 接口定义了一个 `participate` 方法，用于参与文件保存操作。`TrimWhitespaceParticipant` 类实现了该接口，并在 `participate` 方法中执行修剪空白的操作。当文件保存时，`textFileService` 会遍历所有保存参与者并调用其 `participate` 方法，从而实现自动修剪空白的功能。

## `contrib` 的注册

实现一个 `contrib` 和实现一个 `service` 并没有很大差别。以下是 `contrib` 在 VS Code 中的注册方式。

### Registry

VS Code 提供了一个全局注册表，允许模块通过 `Registry.as` 方法访问已注册的实例，而无需显式传递依赖。

```typescript
// add
Registry.add('id', new Class());

// get
Registry.as<Class>('id')
```

这种方式的优点包括：
- **解耦**：通过注册表，模块之间的依赖关系被解耦，降低了耦合度。
- **统一管理**：注册表集中管理模块实例，便于维护和扩展。
- **全局访问**：注册表允许模块在全局范围内被访问，避免显式传递依赖。

### WorkbenchContributionsRegistry

`WorkbenchContributionsRegistry` 是一个单例类，用于管理和启动不同的 `contrib`。

```typescript
class WorkbenchContributionsRegistry extends Disposable implements IWorkbenchContributionsRegistry {
    static readonly INSTANCE = new WorkbenchContributionsRegistry();
    ...
}
Registry.add(Extensions.Workbench, WorkbenchContributionsRegistry.INSTANCE);
```

在工作台初始化过程中（参考：[VSCode-workbench](./[Copilot]VSCode-workbench.md#workbench-初始化)），会通过 `Registry` 获取 `WorkbenchContributionsRegistry` 并进行初始化。

```typescript
class Workbench extends Layout {
    startup(): IInstantiationService {
		try {
            ...
			instantiationService.invokeFunction(accessor => {
                ...
				this.initLayout(accessor);
				Registry.as<IWorkbenchContributionsRegistry>(WorkbenchExtensions.Workbench).start(accessor);
				Registry.as<IEditorFactoryRegistry>(EditorExtensions.EditorFactory).start(accessor);
                ...
				this.renderWorkbench(instantiationService, notificationService, storageService, configurationService);
                ...
			});

			return instantiationService;
		} catch (error) {...}
	}
}
```

### 引入 `contrib`

`contrib` 是通过在 `workbench.desktop.main.ts` 文件中直接引入的方式实现的。例如：

```typescript
/* workbench.desktop.main.ts */
...
import './contrib/localization/electron-sandbox/localization.contribution.js';
...

/* localization.contribution.ts */
const workbenchRegistry = Registry.as<IWorkbenchContributionsRegistry>(WorkbenchExtensions.Workbench);
workbenchRegistry.registerWorkbenchContribution(NativeLocalizationWorkbenchContribution, LifecyclePhase.Eventually);
```

通过这种方式，将 `contrib` 注册到 `WorkbenchContributionsRegistry` 中。

### WorkbenchContributionsRegistry#start 方法

`start` 方法根据生命周期阶段初始化 `contrib`。如果生命周期已经到达，则直接初始化；否则等待生命周期到达后再初始化。

```typescript
class WorkbenchContributionsRegistry extends Disposable implements IWorkbenchContributionsRegistry {
    start(accessor: ServicesAccessor): void {
        ...
		// Instantiate contributions by phase when they are ready
		for (const phase of [LifecyclePhase.Starting, LifecyclePhase.Ready, LifecyclePhase.Restored, LifecyclePhase.Eventually]) {
			this.instantiateByPhase(instantiationService, lifecycleService, logService, environmentService, phase);
		}
        ...
	}
    private instantiateByPhase(...): void {

		// Instantiate contributions directly when phase is already reached
		if (lifecycleService.phase >= phase) {
			this.doInstantiateByPhase(instantiationService, logService, environmentService, phase);
		}

		// Otherwise wait for phase to be reached
		else {
			lifecycleService.when(phase).then(() => this.doInstantiateByPhase(instantiationService, logService, environmentService, phase));
		}
	}
}
```

在 `Starting` 和 `Ready` 阶段，`contrib` 会直接初始化；在 `Restored` 和 `Eventually` 阶段，则会在空闲时初始化。

```typescript
class WorkbenchContributionsRegistry extends Disposable implements IWorkbenchContributionsRegistry {
    start(accessor: ServicesAccessor): void {...}
    private instantiateByPhase(...): void {...}
    private async doInstantiateByPhase(...): Promise<void> {
		if (contributions) {
			switch (phase) {
				case LifecyclePhase.Starting:
				case LifecyclePhase.Ready: {
                    ...
                    this.safeCreateContribution(...)
                    ...
					break;
				}

				case LifecyclePhase.Restored:
				case LifecyclePhase.Eventually: {
                    ...
					this.doInstantiateWhenIdle(...);
					break;
				}
			}
		}
	}
    private safeCreateContribution(...): void {
        ...
        try {
            ...
			const instance = instantiationService.createInstance(contribution.ctor);
		} catch {...} finally {...}
        ...
	}
}
```

## 总结

本文介绍了 VS Code 中 `contrib` 的概念、作用、实现方式以及注册流程。通过 `contrib`，VS Code 实现了模块化设计和功能扩展，同时优化了性能和用户体验。了解 `contrib` 的工作原理，有助于开发者更好地理解 VS Code 的架构设计，并为其扩展功能提供支持。