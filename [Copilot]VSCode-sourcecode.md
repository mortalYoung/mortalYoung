>[!note]
> It's generated by Github Copilot And Thanks [VSCode-sourcecode-analysis
](https://github.com/fzxa/VSCode-sourcecode-analysis/tree/master)

# VSCode 源码解析

## 目录
- [启动流程概览](#启动流程概览)
- [启动前初始化阶段 (beforeReady)](#启动前初始化阶段-beforeready)
  - [性能优化](#性能优化)
  - [便携式判断](#便携式判断)
  - [沙盒配置](#沙盒配置)
  - [UserData](#userdata)
  - [CodeCache](#codecache)
  - [禁用默认菜单](#禁用默认菜单)
  - [崩溃报告](#崩溃报告)
  - [注册自定义协议](#注册自定义协议)
  - [全局应用监听器](#全局应用监听器)
  - [国际化配置](#国际化配置)
- [应用就绪阶段 (ready)](#应用就绪阶段-ready)
  - [性能跟踪](#性能跟踪)
  - [创建代码缓存目录](#创建代码缓存目录)
  - [解析国际化配置](#解析国际化配置)
  - [核心启动流程](#核心启动流程)
- [引导模块系统 (bootstrap-esm.ts)](#引导模块系统-bootstrap-esmts)
  - [fs 模块映射原理](#fs-模块映射原理)
- [主进程启动 (main.ts)](#主进程启动-maints)
  - [启动流程](#启动流程)
  - [应用启动方法](#应用启动方法)
- [窗口管理核心逻辑](#窗口管理核心逻辑)
  - [打开第一个窗口](#打开第一个窗口)
  - [窗口打开实现](#窗口打开实现)
  - [窗口创建与配置](#窗口创建与配置)
  - [窗口加载过程](#窗口加载过程)
- [总结](#总结)

## 启动流程概览

VS Code 的启动流程可以分为几个主要阶段，如下图所示：

```mermaid
flowchart LR
  subgraph beforeReady
    direction TB
    performance["`性能优化(perf.mark)`"]
    portable["`便携式判断(portable mode)`"]
    sandbox["`沙盒配置`"]
    userData["userData"]
    codeCache["codeCache"]
    defaultMenu["disabledDefaultMenu"]
    crashReporter["crash reporter"]
    schemes["Register custom schemes"]
    listeners["Global app listeners"]
    locales["国际化"]
    performance-->portable-->sandbox-->userData-->codeCache-->defaultMenu-->crashReporter-->schemes-->listeners-->locales
  end
  subgraph ready
    direction TB
    trace["trace"]
    mkdir["创建代码缓存目录"]
    resolveNSL["解析国际化配置"]
    startup["**核心启动流程**"]
    trace-->mkdir-->startup
    trace-->resolveNSL-->startup
  end
beforeReady-->ready
```

## 启动前初始化阶段 (beforeReady)

### 性能优化

在启动初期，VS Code 立即设置性能标记点，用于后续分析和优化启动性能。

### 便携式判断

```typescript
// Enable portable support
const portable = configurePortable(product);
...
// Set logs path before app 'ready' event if running portable
// to ensure that no 'logs' folder is created on disk at a
// location outside of the portable directory
// (https://github.com/microsoft/vscode/issues/56651)
if (portable && portable.isPortable) {
	app.setAppLogsPath(path.join(userDataPath, 'logs'));
}
```

### 沙盒配置

<details>
<summary>Github Copilot</summary>

> # VS Code 沙盒配置分析
> 这段代码负责配置 VS Code 中的 Electron 沙盒（sandbox）机制，这是一个重要的安全特性。
> ## 核心功能
> 这部分代码解析命令行参数并配置 Electron 相关的开关选项。
> ## 沙盒策略逻辑
> 这段代码实现了一个三路条件逻辑：
> - 启用沙盒条件：
>   - sandbox 参数为 true
>   - 未指定 disable-chromium-sandbox 命令行参数
>   - 配置文件中未设置 disable-chromium-sandbox: true
> - 特殊情况处理：
>   - 当指定了 --no-sandbox 但未指定 disable-gpu-sandbox 时，禁用 GPU 沙盒
> - 默认行为：
>   - 如果以上条件都不满足，则同时禁用普通沙盒和 GPU 沙盒
> 这是 Electron 应用程序中提高安全性的关键配置，用于隔离应用程序的不同部分，防止潜在的安全漏洞。
</details>

### UserData

<details>
<summary>Github Copilot</summary>

> # `userData` 配置代码分析
> 这段代码是 VS Code 的核心逻辑，负责设置应用程序的用户数据路径。
> ## userData 的作用
> 在 VS Code (以及所有 Electron 应用程序) 中，`userData` 目录是存储用户特定数据的关键位置，包含：
> - 用户设置和首选项
> - 已安装的扩展
> - 工作区配置
> - 应用程序状态信息
> - 临时文件和缓存
> - 日志文件
> ## 代码解析
> ```typescript
> // 在 app 'ready' 事件前设置 userData 路径
> const userDataPath = getUserDataPath(args, product.nameShort ?? 'code-oss-dev');
> if (process.platform === 'win32') {
>    const userDataUNCHost = getUNCHost(userDataPath);
>    if (userDataUNCHost) {
>        addUNCHostToAllowlist(userDataUNCHost); // 启用在 userDataPath 中使用 UNC 路径
>    }
> }
> app.setPath('userData', userDataPath);
> ```
> 这段代码执行两个主要操作：
> 1. 获取用户数据路径：调用 `getUserDataPath()` 函数，传入命令行参数和产品名称
> 2. 将该路径设置为 Electron 的 `userData` 路径
> ## 边界情况处理
> 这里也包含一个边界情况处理：Windows 平台上对 UNC 路径的特殊处理。
> **UNC 路径处理**：
> - 对于 Windows 用户，检查 userData 路径是否是网络路径(如 `\\server\share\folder`)
> - 如果是，调用 `addUNCHostToAllowlist` 函数将该网络主机添加到允许列表中
> - 这确保了 VS Code 可以正确访问存储在网络位置的用户数据
> 这个 UNC 路径处理确保 VS Code 在企业环境中正常工作，即使用户配置文件存储在网络位置。
</details>

### CodeCache

<details>
<summary>Github Copilot</summary>

> # `codeCachePath` 的作用分析
> 这段代码是 VS Code 的核心优化逻辑，用于获取代码缓存路径。
> ## 主要功能
> `codeCachePath` 用于存储 V8 JavaScript 引擎编译后的代码缓存，这是提高 VS Code 启动性能的关键机制。
> ```typescript
> // Resolve code cache path
> const codeCachePath = getCodeCachePath();
> ```
> 通过查看 `getCodeCachePath()` 函数实现，可以了解其详细逻辑：
> ```typescript
> function getCodeCachePath(): string | undefined {
> 	// 如果通过命令行参数明确禁用
> 	if (process.argv.indexOf('--no-cached-data') > 0) {
> 		return undefined;
> 	}
> 	// 开发模式下不使用缓存
> 	if (process.env['VSCODE_DEV']) {
> 		return undefined;
> 	}
> 	// 需要 commit ID
> 	const commit = product.commit;
> 	if (!commit) {
> 		return undefined;
> 	}
> 	return path.join(userDataPath, 'CachedData', commit);
> }
> ```
> ## 技术原理
> 代码缓存的工作原理：
> - 缓存 JS 代码的编译结果（字节码），避免每次启动时重新解析和编译
> - 路径包含特定的 commit ID，确保不同版本使用独立的缓存
> - 显著减少启动时间，特别是在大型应用如 VS Code 中效果明显
> ## 使用方式
> 在应用启动过程中，该路径被设置为环境变量并在后续初始化步骤中使用：
> ```typescript
> process.env['VSCODE_CODE_CACHE_PATH'] = codeCachePath || '';
> ```
> 这个优化对 VS Code 的快速启动至关重要，尤其当应用规模不断增长时。
</details>

### 禁用默认菜单

<details>
<summary>Github Copilot</summary>

> # `Menu.setApplicationMenu(null)` 分析
> 这行代码是 VSCode 的**核心逻辑**部分，而不是处理边界情况。
> ```typescript
> // Disable default menu (https://github.com/electron/electron/issues/35512)
> Menu.setApplicationMenu(null);
> ```
> ## 功能说明
> 这段代码通过将应用程序菜单设置为 `null` 来禁用 Electron 的默认菜单栏。这是 VSCode 启动流程中的一个重要步骤，因为：
> 1. VSCode 实现了自己的自定义菜单系统，不依赖 Electron 的默认菜单
> 2. 需要先禁用默认菜单，然后在应用程序的其他部分再创建和设置自定义菜单
> ## 实现原因
> 注释中引用的 GitHub issue (#35512) 说明这是有意为之的设计选择，与 Electron 默认菜单行为有关。VSCode 需要完全控制其菜单系统，以提供一致的跨平台体验和丰富的自定义选项。
> 此代码与沙盒配置、用户数据路径设置等一样，都是 VSCode 启动过程中的基础设置步骤，属于应用程序初始化阶段的核心逻辑。
</details>

### 崩溃报告

VS Code 在启动过程中配置崩溃报告器，以捕获应用程序的意外崩溃并提供诊断信息。

### 注册自定义协议

<details>
<summary>Github Copilot</summary>

> # 自定义协议注册分析
> 这段代码是 VS Code 的**核心逻辑**，负责注册和配置 VS Code 使用的两个关键自定义 URL 协议。
> ## 功能解析
> ```typescript
> // Register custom schemes with privileges
> protocol.registerSchemesAsPrivileged([
> 	{
> 		scheme: 'vscode-webview',
> 		privileges: { standard: true, secure: true, supportFetchAPI: true, corsEnabled: true, allowServiceWorkers: true, codeCache: true }
> 	},
> 	{
> 		scheme: 'vscode-file',
> 		privileges: { secure: true, standard: true, supportFetchAPI: true, corsEnabled: true, codeCache: true }
> 	}
> ]);
> ```
> 该代码注册了两个自定义 URL 协议：
> 1. **vscode-webview**：为 VS Code 的 WebView 功能提供支持
>    - 具有完整特权集，包括 Service Worker 支持
>    - 允许 WebView 内容安全地与主进程通信
> 2. **vscode-file**：提供对本地文件的安全访问
>    - 与标准文件协议不同，具有额外安全约束
>    - 支持代码缓存以提高性能
> 这是 VS Code 架构的基础部分，没有这些自定义协议的注册，编辑器的许多核心功能（如扩展 UI、Markdown 预览、自定义编辑器等）都无法正常工作。
> 这些协议注册必须在应用初始化阶段完成，以确保 Electron 的渲染器进程能够正确识别和处理这些特殊 URL。
</details>

### 全局应用监听器

<details>
<summary>Github Copilot</summary>

> # `registerListeners()` 分析
> 这段代码是 VS Code 的**核心逻辑**，负责设置全局应用程序事件监听器。
> ## 主要功能
> ```typescript
> // Global app listeners
> registerListeners();
> ```
> 这行代码调用的 `registerListeners()` 函数在 VS Code 启动过程中扮演着关键角色，它：
> 1. 注册处理文件打开请求的事件监听器
> 2. 设置 URL 协议处理的事件回调
> ## 具体实现
> 查看 `registerListeners()` 函数的完整实现：
> ```typescript
> function registerListeners(): void {
> 	/**
> 	 * macOS: when someone drops a file to the not-yet running VSCode, the open-file event fires even before
> 	 * the app-ready event. We listen very early for open-file and remember this upon startup as path to open.
> 	 */
> 	const macOpenFiles: string[] = [];
> 	(globalThis as any)['macOpenFiles'] = macOpenFiles;
> 	app.on('open-file', function(event, path) {
> 		macOpenFiles.push(path);
> 	});
> 	/**
> 	 * macOS: react to open-url requests.
> 	 */
> 	const openUrls: string[] = [];
> 	const onOpenUrl = function(event: { preventDefault: () => void }, url: string) {
> 		event.preventDefault();
> 		openUrls.push(url);
> 	};
> 	app.on('will-finish-launching', function() {
> 		app.on('open-url', onOpenUrl);
> 	});
> 	(globalThis as any)['getOpenUrls'] = function() {
> 		app.removeListener('open-url', onOpenUrl);
> 		return openUrls;
> 	};
> }
> ```
> 这是 VS Code 启动流程的核心部分，确保应用程序能够正确响应各种外部请求。
</details>

### 国际化配置

<details>
<summary>Github Copilot</summary>

> # VS Code 国际化配置分析
> 这段代码是 VS Code 的**核心逻辑**和**边界情况处理**的结合，负责设置应用程序的国际化（i18n）支持。
> ## 核心逻辑部分
> ```typescript
> // 可以在 app.ready 事件前解析 NLS 配置（如果在 argv.json 中已定义）
> // 否则只能在 app.ready 事件后解析 NLS，以获取 OS 区域设置
> let nlsConfigurationPromise: Promise<INLSConfiguration> | undefined = undefined;
> // 获取操作系统首选语言用于语言推荐
> // 在 Linux 上，当用户仅配置了 'C' 区域设置时，API 可能返回空数组
> // 无论哪种操作系统，如果数组为空，默认使用 'en'
> const osLocale = processZhLocale((app.getPreferredSystemLanguages()?.[0] ?? 'en').toLowerCase());
> const userLocale = getUserDefinedLocale(argvConfig);
> if (userLocale) {
> 	nlsConfigurationPromise = resolveNLSConfiguration({
> 		userLocale,
> 		osLocale,
> 		commit: product.commit,
> 		userDataPath,
> 		nlsMetadataPath: __dirname
> 	});
> }
> ```
> ## 边界情况处理
> ```typescript
> // 传入区域设置到 Electron，确保 Windows Control Overlay 在 Windows 上正确渲染
> // 由于 https://github.com/microsoft/vscode/issues/167543 问题
> // 暂时不在 macOS 上传入区域设置
> // 如果区域设置是 `qps-ploc`，表示使用的是微软伪语言包
> // 在这种情况下，使用 `en` 作为 Electron 区域设置
> if (process.platform === 'win32' || process.platform === 'linux') {
> 	const electronLocale = (!userLocale || userLocale === 'qps-ploc') ? 'en' : userLocale;
> 	app.commandLine.appendSwitch('lang', electronLocale);
> }
> ```
> 这段代码处理了几个重要的边界情况：
> 1. 中文语言特殊处理 (`processZhLocale` 函数)
> 2. 在没有找到区域设置时回退到英语
> 3. 微软伪语言包 (`qps-ploc`) 的特殊处理
> 4. macOS 平台的特殊处理（不设置区域设置）
> 这是 VS Code 作为全球化应用程序的关键部分，确保不同语言环境的用户都能获得良好体验。
</details>

## 应用就绪阶段 (ready)

### 性能跟踪

<details>
<summary>Github Copilot</summary>

> # 调试跟踪配置代码分析
> 这段代码是**边界情况处理**，专门用于支持调试和性能分析场景，而不是 VS Code 的核心运行逻辑。
> ## 功能解析
> ```typescript
> if (args['trace']) {
> 	let traceOptions: Electron.TraceConfig | Electron.TraceCategoriesAndOptions;
> 	if (args['trace-memory-infra']) {
> 		const customCategories = args['trace-category-filter']?.split(',') || [];
> 		customCategories.push('disabled-by-default-memory-infra', 'disabled-by-default-memory-infra.v8.code_stats');
> 		traceOptions = {
> 			included_categories: customCategories,
> 			excluded_categories: ['*'],
> 			memory_dump_config: {
> 				allowed_dump_modes: ['light', 'detailed'],
> 				triggers: [
> 					{
> 						type: 'periodic_interval',
> 						mode: 'detailed',
> 						min_time_between_dumps_ms: 10000
> 					},
> 					{
> 						type: 'periodic_interval',
> 						mode: 'light',
> 						min_time_between_dumps_ms: 1000
> 					}
> 				]
> 			}
> 		};
> 	} else {
> 		traceOptions = {
> 			categoryFilter: args['trace-category-filter'] || '*',
> 			traceOptions: args['trace-options'] || 'record-until-full,enable-sampling'
> 		};
> 	}
> 	contentTracing.startRecording(traceOptions).finally(() => onReady());
> } else {
> 	onReady();
> }
> ```
> 这段代码是一个特殊的调试工具，仅在使用 `--trace` 命令行参数启动 VS Code 时才会激活。它提供两种不同的跟踪配置：
> 1. **内存基础设施跟踪** (通过 `--trace-memory-infra` 启用)：
>    - 配置定期内存转储（轻量和详细两种模式）
>    - 包含特定内存相关的跟踪类别
> 2. **一般性能跟踪**：
>    - 使用命令行提供的类别过滤器或默认跟踪所有类别
>    - 允许自定义跟踪选项
> 无论是否启用跟踪，最终都会调用 `onReady()` 继续应用程序的启动流程。
> 这属于边界情况处理，因为它:
> - 仅在特定命令行参数存在时才激活
> - 服务于调试/诊断而非核心功能
> - 普通用户几乎不会使用这些参数
</details>

### 创建代码缓存目录

在应用就绪后，VS Code 会检查并创建代码缓存目录，以确保后续的代码缓存操作能够正常进行。

### 解析国际化配置

应用就绪后，完成国际化配置的最终解析，获取操作系统语言设置并应用用户指定的语言偏好。

### 核心启动流程

<details>
<summary>Github Copilot</summary>

> # `startup` 函数分析
> 这段代码是 VS Code 的**核心逻辑**，实现了 VS Code 的主要启动流程。
> ## 函数分析
> ```typescript
> /**
>  * Main startup routine
>  */
> async function startup(codeCachePath: string | undefined, nlsConfig: INLSConfiguration): Promise<void> {
> 	process.env['VSCODE_NLS_CONFIG'] = JSON.stringify(nlsConfig);
> 	process.env['VSCODE_CODE_CACHE_PATH'] = codeCachePath || '';
> 	// Bootstrap ESM
> 	await bootstrapESM();
> 	// Load Main
> 	await import('./vs/code/electron-main/main.js');
> 	perf.mark('code/didRunMainBundle');
> }
> ```
> 这个函数是 VS Code 启动的核心，执行以下几个关键步骤：
> 1. **配置环境变量**：设置国际化配置和代码缓存路径
> 2. **引导模块系统**：通过 `bootstrapESM()` 初始化 ES 模块系统
> 3. **加载主程序**：动态导入主模块 `./vs/code/electron-main/main.js`
> 4. **性能标记**：记录完成主程序包运行的性能时间点
> 这个函数本质上是应用程序启动序列的核心部分，而不是处理边缘情况的代码。它代表了 VS Code 从 Electron 层到实际应用程序加载的关键转换点。
</details>

## 引导模块系统 (bootstrap-esm.ts)

<details>
<summary>Github Copilot</summary>

> # bootstrap-esm.ts 文件分析
> ## 文件作用
> bootstrap-esm.ts 是 VS Code 核心启动过程中的关键组件，负责引导 ECMAScript 模块 (ESM) 系统并完成以下核心初始化任务：
> 1. **模块解析钩子配置**
>    - 将 'fs' 模块重定向到 'original-fs'，确保在 Electron 环境中正确处理文件系统操作
>    - 注册特殊的模块加载器以处理特定的模块解析逻辑
> 2. **全局状态初始化**
>    - 设置关键全局变量如 `_VSCODE_PRODUCT_JSON` 和 `_VSCODE_PACKAGE_JSON`
>    - 处理开发环境下的产品配置覆盖
> 3. **国际化 (NLS) 支持**
>    - 加载和配置本地化资源
>    - 处理语言包的加载和回退逻辑
>    - 记录性能指标以跟踪 NLS 加载时间
> ## 主要功能
> 文件导出一个关键函数 `bootstrapESM()`，在主应用程序启动序列中被调用：
> ```typescript
> export async function bootstrapESM(): Promise<void> {
>     // NLS
>     await setupNLS();
> }
> ```
> ## 如果缺少此文件的后果
> 如果这个文件不存在，VS Code 将无法正常启动：
> 1. **启动序列中断**
>    - main.ts 中的 `startup()` 函数直接调用 `bootstrapESM()`
>    - 缺少这个函数会导致启动流程中断
> 2. **模块加载失败**
>    - 没有 fs 模块重定向，将导致 Electron 环境中的文件系统操作不可靠
> 3. **国际化支持缺失**
>    - 无法加载语言包
>    - 所有界面将回退到默认英文，忽略用户语言首选项
> 4. **全局配置缺失**
>    - 依赖全局产品信息的代码将失败
>    - 无法正确识别产品特性和配置
> 5. **性能跟踪受损**
>    - 性能标记点缺失，影响诊断和性能分析能力
> 这个文件是 VS Code 模块化架构和启动流程的核心部分，确保应用程序的各个组件能够正确初始化和协同工作。
</details>

### fs 模块映射原理

<details>
<summary>Github Copilot</summary>

> # Purpose of Mapping 'fs' to 'original-fs'
> This code maps the 'fs' module to 'original-fs' in Electron environments for an important reason:
> In Electron applications, the standard 'fs' module is often modified to implement security restrictions or provide sandboxed file system operations for renderer processes. These restrictions could limit VS Code's ability to perform necessary file operations.
> The 'original-fs' module in Electron provides access to the unmodified Node.js file system API with full capabilities. By redirecting 'fs' imports to 'original-fs', the code ensures VS Code can use unrestricted file system access when running in an Electron context.
> The implementation:
> 1. Only activates in Electron environments (checked with conditions)
> 2. Uses a custom ES module loader hook to intercept 'fs' imports
> 3. Redirects them to 'node:original-fs'
> This ensures VS Code maintains full file system access capabilities necessary for its core functionality like reading/writing files and working with project directories.
</details>

## 主进程启动 (main.ts)

核心入口代码主要负责创建和初始化 VS Code 的主进程服务。

### 启动流程

```mermaid
flowchart LR
createServices["创建Services"]
initServices["初始化Services"]
startup["启动"]
createServices-->initServices-->startup
```

### 应用启动方法

在 startup 中触发 CodeApplication 实例的 startup 方法，该方法进行如下操作：

```mermaid
flowchart LR
log["日志相关"]
platform["特定平台配置"]
ipcMain["ipcMain初始化"]
sqmId["唯一标识符"]
sharedProcess["共享进程"]
services["初始化服务"]
initChannels["初始化ipc"]
invoke["一系列初始化"]
openFirstWindow["打开首个窗口"]
after["打开窗口的任务"]
log-->platform-->ipc-->sqmId-->sharedProcess-->services-->initChannels-->invoke-->openFirstWindow-->after
```

#### 唯一标识符

VS Code 会生成一个唯一的机器标识符。这对于设置同步等功能特别重要，在这些功能中，正确识别不同的机器对于跨多个设备同步用户数据至关重要。

#### 初始化ipc

<details>
<summary>Github Copilot</summary>

> # initChannels 方法的作用
> `initChannels` 方法在 VS Code 的主进程中负责初始化和注册进程间通信(IPC)通道。这些通道使 VS Code 的主进程能够与其他进程(如渲染进程和共享进程)进行通信。
> ## 主要功能
> 1. **创建通信桥梁**：为 VS Code 的各个组件之间建立通信机制
> 2. **注册服务通道**：将主进程中的各种服务转换为可通过 IPC 访问的通道
> ## 注册的通道类型
> 方法将通道注册到三个不同的目标：
> 1. **mainProcessNodeIpcServer**：用于第一个和第二个 VS Code 实例之间的通信
> 2. **mainProcessElectronServer**：用于主进程与渲染进程之间的通信
> 3. **sharedProcessClient**：用于主进程与共享进程之间的通信
> ## 注册的重要服务通道
> 该方法注册了大量服务通道，包括：
> - **系统功能**：启动(`launch`)、更新(`update`)、进程管理(`process`)
> - **文件操作**：本地文件系统访问
> - **安全与加密**：加密服务、签名服务、策略管理
> - **UI组件**：菜单栏、Webview管理
> - **数据管理**：存储服务、用户数据配置文件
> - **开发工具**：诊断服务、日志记录、扩展主机调试
> - **终端相关**：终端服务、外部终端集成
> 通过这种通道设计，VS Code 实现了一个模块化的架构，其中不同的进程可以安全地访问彼此的功能，而无需共享内存空间，提高了应用程序的稳定性和可扩展性。
</details>

## 窗口管理核心逻辑

### 打开第一个窗口

<details>
<summary>Github Copilot</summary>

> # openFirstWindow 方法详解
> `openFirstWindow` 方法是 VS Code 启动过程中的关键环节，负责决定首次启动时应该打开什么内容。这个方法需要处理多种启动场景，包括从协议链接、命令行参数、系统事件等各种方式启动 VS Code 时应该展示什么内容。
> ## 方法整体作用
> 此方法负责确定并打开 VS Code 启动时用户看到的第一个窗口，包括:
> - 决定打开空窗口还是特定内容
> - 处理通过协议链接（如 vscode:// URL）启动的情况
> - 响应命令行参数
> - 处理操作系统特定的文件打开事件（特别是 macOS）
> ## 分支判断详解
> 方法包含多个 if-else 分支，每个分支处理不同的启动场景：
> ### 1. 协议 URL 启动分支
> ```typescript
> if (initialProtocolUrls) {
>     // 子分支1: 可直接作为窗口打开的 URL
>     if (initialProtocolUrls.openables.length > 0) {
>         // 打开协议 URL 指定的文件/文件夹/工作区
>     }
>     // 子分支2: 请求在新窗口中处理的协议 URL
>     if (initialProtocolUrls.urls.length > 0) {
>         for (const protocolUrl of initialProtocolUrls.urls) {
>             if (params.get('windowId') === '_blank') {
>                 // 打开空白窗口，稍后处理此 URL
>             }
>         }
>     }
> }
> ```
> **示例**:
> - 当用户点击 `vscode://file/path/to/project` 链接时，VS Code 会启动并直接打开该项目
> - 当扩展请求在新窗口中打开内容时，如 `vscode://vscode.github-authentication?windowId=_blank`
> ### 2. 无文件/文件夹参数启动分支
> ```typescript
> if (!hasCliArgs && !hasFolderURIs && !hasFileURIs) {
>     // 子分支1: 强制新窗口
>     if (args['new-window'] || forceProfile || forceTempProfile) {
>         // 打开空白新窗口
>     }
>     // 子分支2: macOS 特定处理
>     if (macOpenFiles.length) {
>         // 打开通过 Finder 拖放或"打开方式"选择的文件
>     }
> }
> ```
> **示例**:
> - 用户通过 `code --new-window` 命令启动，将打开一个空白窗口
> - 用户指定特定配置文件启动 `code --profile myprofile`，将打开空白窗口使用该配置
> - 在 macOS 上，用户将文件拖到 VS Code 图标上启动应用
> ### 3. 默认启动分支（有命令行参数）
> ```typescript
> // 默认行为：从命令行读取路径
> return windowsMainService.open({
>     // 各种参数...
> });
> ```
> **示例**:
> - 用户执行 `code /path/to/project` 将直接打开该项目
> - 用户执行 `code --diff file1 file2` 将在差异模式下打开两个文件
> - 用户执行 `code file.txt:42` 将打开文件并跳转到第42行
> ## 总结
> `openFirstWindow` 方法是 VS Code 启动体验的核心，它处理了多种不同的启动场景，确保无论用户如何启动 VS Code，都能获得一致且符合预期的体验。这种灵活性使 VS Code 能够无缝集成到不同的工作流程和操作系统环境中。
</details>

### 窗口打开实现

VS Code 窗口打开流程分为三个主要阶段：

```mermaid
flowchart LR
beforeDoOpen["配置收集"]
doOpen["doOpen"]
afterOpen["处理焦点及最近打开"]
beforeDoOpen-->doOpen-->afterOpen
```

<details>
<summary>Github Copilot</summary>

> # VS Code 的 open 方法详解
> `open` 方法是 VS Code 窗口管理系统中的核心方法，负责处理各种内容的打开逻辑，包括文件、文件夹和工作区。这个方法位于 `WindowsMainService` 类中，是所有窗口打开操作的中央控制器。
> ## 核心功能
> 这个方法的主要职责是：
> 1. **确定要打开的内容**：解析用户想要打开的内容（文件、文件夹、工作区）
> 2. **决定打开方式**：确定内容应该在新窗口还是现有窗口中打开
> 3. **处理窗口状态**：管理窗口的创建、重用和焦点
> 4. **支持特殊模式**：处理差异比较、合并文件、命令行等待等特殊模式
> ## 方法参数
> ```typescript
> async open(openConfig: IOpenConfiguration): Promise<ICodeWindow[]>
> ```
> `openConfig` 参数包含了控制打开行为的所有配置，如：
> - 打开上下文（CLI、桌面、菜单等）
> - 命令行参数
> - 是否应该在新窗口打开
> - 是否为添加/移除文件夹模式
> - 要打开的 URI 列表
> ## 主要流程
> 1. **路径收集**：调用 `getPathsToOpen` 收集所有要打开的路径
>    ```typescript
>    const pathsToOpen = await this.getPathsToOpen(openConfig);
>    ```
> 2. **路径分类**：将收集到的路径分类为文件夹、工作区、文件等
>    ```typescript
>    for (const path of pathsToOpen) {
>      if (isSingleFolderWorkspacePathToOpen(path)) {
>        // 处理文件夹...
>      } else if (isWorkspacePathToOpen(path)) {
>        // 处理工作区...
>      } else if (path.fileUri) {
>        // 处理文件...
>      }
>    }
>    ```
> 3. **特殊模式处理**：
>    ```typescript
>    // 差异比较模式
>    if (openConfig.diffMode && filesToOpen && filesToOpen.filesToOpenOrCreate.length >= 2) {
>      filesToOpen.filesToDiff = filesToOpen.filesToOpenOrCreate.slice(0, 2);
>      filesToOpen.filesToOpenOrCreate = [];
>    }
>    
>    // 合并模式
>    if (openConfig.mergeMode && filesToOpen && filesToOpen.filesToOpenOrCreate.length === 4) {
>      filesToOpen.filesToMerge = filesToOpen.filesToOpenOrCreate.slice(0, 4);
>      // ...
>    }
>    ```
> 4. **执行打开操作**：调用 `doOpen` 方法实际打开窗口
>    ```typescript
>    const { windows: usedWindows, filesOpenedInWindow } = await this.doOpen(openConfig, workspacesToOpen, foldersToOpen, /* ... */);
>    ```
> 5. **焦点管理**：确定哪个窗口应该获得焦点
>    ```typescript
>    if (usedWindows.length > 1) {
>      // 有多个窗口时的焦点逻辑
>      if (filesOpenedInWindow) {
>        filesOpenedInWindow.focus();
>      } else {
>        // 其他焦点分配逻辑
>      }
>    }
>    ```
> 6. **记录历史**：添加到最近打开的历史记录中
>    ```typescript
>    this.workspacesHistoryMainService.addRecentlyOpened(recents);
>    ```
> ## 主要场景
> `open` 方法处理的场景包括：
> 1. **从命令行打开**：处理 `code file.txt` 或 `code folder/` 等命令
> 2. **从 GUI 打开**：处理从文件资源管理器、Dock 等打开的情况
> 3. **会话恢复**：启动时恢复上次的窗口
> 4. **差异比较**：使用 `--diff` 比较两个文件
> 5. **文件合并**：使用 `--merge` 合并文件
> 6. **远程开发**：处理远程开发场景下的窗口打开
> 总之，`open` 方法是 VS Code 窗口系统的核心入口点，协调了所有窗口打开操作，确保用户体验的一致性和可预测性。
</details>

`doOpen` 方法负责确定内容应该在哪个窗口中打开，根据不同的条件，它会触发不同的窗口打开方式，其中 `openInBrowserWindow` 是创建新窗口最核心的方法。

### 窗口创建与配置

窗口创建流程主要包括以下步骤：

```mermaid
flowchart LR
before["窗口配置构建"]
createWindow["创建 window"]
doOpenInBrowserWindow["doOpenInBrowserWindow"]
before-->createWindow-->doOpenInBrowserWindow
```

<details>
<summary>Github Copilot</summary>

> # VS Code 的 openInBrowserWindow 方法详解
> `openInBrowserWindow` 方法是 VS Code 窗口管理系统的核心方法，负责实际创建或重用 Electron 窗口来打开 VS Code 内容。这是最低层的窗口创建逻辑，处理所有与 Electron 窗口相关的配置和生命周期。
> ## 主要功能
> 该方法接收 `IOpenBrowserWindowOptions` 参数，包含要打开的内容和窗口行为的配置信息，最终返回一个已配置并加载的 `ICodeWindow` 实例。
> 主要职责包括：
> 1. **窗口创建与重用决策**
>    - 根据参数决定是创建新窗口还是重用现有窗口
>    - 处理窗口选项卡管理（macOS）
> 2. **窗口配置构建**
>    - 生成完整的窗口配置（`INativeWindowConfiguration`）
>    - 包括命令行参数、机器标识、路径配置、用户环境变量等
>    - 配置工作区、文件、差异比较、合并等目标
> 3. **窗口备份与恢复**
>    - 通过 `backupMainService` 注册工作区、文件夹或空窗口的备份
>    - 支持崩溃恢复和会话还原
> 4. **用户配置文件管理**
>    - 解析并应用适当的用户配置文件（profile）
>    - 处理强制配置文件和临时配置文件情况
>    - 将配置文件与工作区关联
> 5. **窗口生命周期与事件管理**
>    - 注册窗口事件（就绪、关闭、销毁等）
>    - 维护窗口计数和窗口列表
>    - 处理最大化、全屏等状态变化
> ## 执行流程
> 1. 首先尝试确定要使用的配置文件（默认、新窗口或强制指定）
> 2. 根据传入参数决定是重用现有窗口还是创建新窗口
> 3. 构建完整的窗口配置
> 4. 对于新窗口：创建实例、注册事件、添加到窗口列表
> 5. 对于现有窗口：处理配置继承，特别是扩展开发相关的设置
> 6. 注册备份路径（用于崩溃恢复）
> 7. 解析并设置用户配置文件
> 8. 使用配置加载窗口
> 这个方法是整个 VS Code 窗口系统的基石，确保窗口按照正确且一致的方式创建和加载，同时支持崩溃恢复和会话保存等高级功能。
</details>

<details>
<summary>Github Copilot</summary>

> # VS Code 的 doOpenInBrowserWindow 方法详解
> `doOpenInBrowserWindow` 方法是 VS Code 窗口系统中的核心方法，负责将配置应用到浏览器窗口并完成窗口加载过程。这是 `openInBrowserWindow` 方法的后半部分逻辑，处理的是窗口配置的完成和实际加载操作。
> ## 主要功能
> 此方法执行以下关键操作：
> 1. **备份路径注册**：为不同类型的窗口内容创建和注册备份路径
>    ```typescript
>    if (!configuration.extensionDevelopmentPath) {
>        if (isWorkspaceIdentifier(configuration.workspace)) {
>            configuration.backupPath = this.backupMainService.registerWorkspaceBackup({
>                workspace: configuration.workspace,
>                remoteAuthority: configuration.remoteAuthority
>            });
>        } else if (isSingleFolderWorkspaceIdentifier(configuration.workspace)) {
>            // 为单文件夹工作区注册备份
>        } else {
>            // 为空窗口注册备份
>        }
>    }
>    ```
> 2. **用户配置文件解析**：确定应该使用哪个用户配置文件
>    ```typescript
>    const workspace = configuration.workspace ?? toWorkspaceIdentifier(configuration.backupPath, false);
>    const profilePromise = this.resolveProfileForBrowserWindow(options, workspace, defaultProfile);
>    const profile = profilePromise instanceof Promise ? await profilePromise : profilePromise;
>    configuration.profiles.profile = profile;
>    ```
> 3. **配置文件关联**：将配置文件与工作区永久关联（除非是扩展开发窗口）
>    ```typescript
>    if (!configuration.extensionDevelopmentPath) {
>        await this.userDataProfilesMainService.setProfileForWorkspace(workspace, profile);
>    }
>    ```
> 4. **窗口加载**：使用完整配置加载窗口
>    ```typescript
>    window.load(configuration);
>    ```
> ## 工作流程
> 1. 首先，如果窗口不是用于扩展开发，会根据内容类型（工作区、文件夹或空窗口）注册相应的备份
> 2. 然后，解析当前应用的用户配置文件（考虑强制配置文件和临时配置文件选项）
> 3. 将配置文件与工作区关联，便于下次自动使用相同配置
> 4. 最终，将完整配置应用到窗口并触发加载
> 这个方法是 VS Code 窗口生命周期中关键的一步，它确保窗口有正确的备份路径、用户配置文件以及与工作区的持久关联，这些都是 VS Code 用户体验的重要部分。
</details>

### 窗口加载过程

窗口加载过程主要分为三个阶段：

```mermaid
flowchart LR
before["处理配置及状态更新"]
loadURL["loadURL"]
after["状态更新及事件触发"]
before-->loadURL-->after
```

核心加载代码：
```ts
this._win.loadURL(FileAccess.asBrowserUri(`vs/code/electron-sandbox/workbench/workbench${this.environmentMainService.isBuilt ? '' : '-dev'}.html`).toString(true));
```

<details>
<summary>Github Copilot</summary>

> # VS Code 中 `load` 方法的作用详解
> `load` 方法是 `CodeWindow` 类中的核心方法，负责配置并加载 VS Code 窗口的内容。这个方法处理从准备窗口状态到实际加载 Web 内容的整个过程。
> ## 主要功能
> 1. **窗口状态清理**：
>    - 清除文档的"已编辑"状态（如果需要）
>    - 清除窗口标题和代表文件名（如果不是重新加载）
> 2. **配置处理**：
>    - 通过 `updateConfiguration` 更新基于当前窗口上下文的配置值
>    - 将配置放入配置对象 URL 中，供渲染进程使用
> 3. **配置关联逻辑**：
>    - 如果是窗口第一次加载（`readyState === ReadyState.NONE`），直接将配置与窗口关联
>    - 如果窗口已经显示内容，将配置存储为待处理配置（`pendingLoadConfig`），等待窗口加载事件触发后再关联
> 4. **状态转换**：
>    - 将窗口的 `readyState` 设置为 `NAVIGATING`，表示窗口正在导航中
> 5. **加载 Web 内容**：
>    - 加载 VS Code 的主界面 HTML 文件（workbench.html）
> 6. **加载状态记录**：
>    - 记录窗口已经被加载过（`wasLoaded = true`）
> 7. **安全措施**：
>    - 在开发模式下，设置一个定时器，如果窗口在特定时间内没有变为可见，则强制显示窗口并打开开发者工具
> 8. **事件触发**：
>    - 触发 `onWillLoad` 事件，通知其他组件窗口即将加载
> ## 为什么这个方法很重要
> `load` 方法是 VS Code 窗口生命周期中的关键环节，它：
> 1. 连接了命令行参数、配置系统和实际的窗口内容
> 2. 处理了首次加载和重新加载的不同逻辑
> 3. 确保窗口状态的正确性和一致性
> 4. 管理渲染进程与主进程之间的配置传递
> 总的来说，`load` 方法是窗口显示内容前的"准备阶段"，它设置了必要的状态和配置，然后触发实际的内容加载过程。
</details>

## 总结

通过对 VS Code 源码的分析，我们可以清晰地看到它的启动流程分为几个关键阶段：

1. **启动前初始化阶段**：在 Electron 的 `app.ready` 事件触发前，VS Code 完成了一系列基础配置，包括性能标记、便携模式检测、沙盒配置、用户数据路径设置、代码缓存路径确定、禁用默认菜单、崩溃报告器设置、自定义协议注册、全局事件监听器注册以及国际化支持等。

2. **应用就绪阶段**：在 `app.ready` 事件触发后，VS Code 进行性能跟踪配置、创建代码缓存目录、完成国际化配置解析，最终启动核心流程。

3. **模块系统初始化**：通过 `bootstrap-esm.ts` 初始化 ECMAScript 模块系统，特别是处理 `fs` 模块到 `original-fs` 的映射，以确保在 Electron 环境中正确访问文件系统。

4. **主进程启动**：在 `src/vs/code/electron-main/main.ts` 中，创建和初始化核心服务，然后启动应用程序主流程，包括日志系统、平台特定配置、IPC 通道初始化、唯一标识符生成、共享进程管理等。

5. **窗口管理**：最终，VS Code 通过 `openFirstWindow` 方法打开第一个窗口，根据不同的启动场景（如命令行参数、协议链接、文件拖放等）决定打开什么内容。窗口的创建和配置通过 `openInBrowserWindow` 和 `doOpenInBrowserWindow` 方法完成，最后通过 `load` 方法加载实际的窗口内容。

这种多阶段的启动设计使 VS Code 能够灵活处理各种启动场景和用户需求，同时保持性能和稳定性。模块化的架构和服务设计也使得代码组织清晰，便于维护和扩展，为 VS Code 作为一个功能强大且高度可定制的编辑器提供了坚实的基础。

## 参考资料
[Source Code Organization](https://github.com/microsoft/vscode/wiki/Source-Code-Organization)