# 数据结构快速复习

## 栈、队列和数组
### 栈
1. 栈（Stack）只允许在一端进行插入或删除操作的线性表
    - 线性表
    - 操作受限的线性表 只允许在一端插入和删除
    - 可操作的一端叫栈顶，不可操作的一端叫栈底
    - 没有任何元素的空表叫空栈
    - 操作特性为后进先出（Last In First Out, LIFO）
2. 栈的基本操作包括
    - InitStack(&S): 初始化空栈 S
    - StackEmpty(S): 判断一个栈是否为空
    - Push(&S, x): 进栈，若 S 未满，则 x 进栈成为新栈顶
        - 进栈时，指针先加一，再入栈
    - Pop(&S, &x): 出栈，若 S 非空，则弹出栈顶元素，用 x 返回
        - 出栈时，先出栈，再指针减一
    - GetTop(S, &x): 读取栈顶元素，若 S 非空，则用 x 返回栈顶元素
    - DestoryStack(&S): 销毁栈，释放栈的储存空间
3. 栈的顺序结构
    - 连续的内存地址分配
    - 共享栈
        - 利用栈底位置不变的特性，两个顺序栈共享一个数据空间
        - 两个栈的栈底分别位于空间两端，指针向空间中间移动
        - 当两个指针相连的时候，则栈满
4. 栈的链式存储结构
    - 链栈
    - 操作与链表类型
### 队列
1. 队列（Queue）只允许在表的一端进行插入，而在表的另一端进行删除
    - 线性表
    - 操作受限的线性表
    - 插入元素叫入队或进队，删除元素叫出队或离队
    - 入队的一端叫队尾，出队的一端叫队头
    - 不含任何元素的空表叫空队列
2. 队列的基本操作
    - 略
3. 队列的顺序结构
    - front 指针和 rear 指针分别指向队头和队尾
    - 初始化时 `front == rear == 0` 即队空的判断
    - 进队：先送值到队尾，再 `rear += 1`
    - 出队：先取队头元素，再 `front += 1`
    - 队满条件判断：不可使用 `rear == MaxSize` 因为队列存在 “上溢出”
    - 由于存在上溢出的缺点，所以有一种队列叫**循环队列**
        - 即把存储队列元素的表**从逻辑**上视为一个环
        - 当队首指针 `front == MaxSize - 1` 后, 再前进一个位置就归零
        - 初始化：`front == rear == 0`
        - 队首指针进一操作：`front = (front + 1) % MaxSize`
        - 队尾指针进一操作：`rear = (rear + 1) % MaxSize`
        - 队列长度：`(rear + MaxSize - front) % MaxSize`
        - 队空判断：`front == rear`
        - 队满同样是 `front == rear`
            - 牺牲一个单元来区分队空和队满
                - 队满：`(rear + 1) % MaxSize == front`
                - 队空：`front == rear`
                - 队列长度：`(rear - front + MaxSize) % MaxSize`
            - 在定义类型的时候新增表示元素个数的数据类型
                ```C++
                #define MaxSize 50
                typedef struct {
                    ElemType data[MaxSize];
                    int front;rear;
                    int length;
                } SqQueue
                ```
            - 在定义类型的时候增设 tag 来区分，总的来说和上一个方法类似
4. 队列的链式存储
	- 链队列实际上就是带有头尾指针的单链表
	- 当 `Q.front == null && Q.rear == null` 时，链队列为空
	- 适合用于数据元素变动比较大的情形，不存在队列满且溢出的问题
	- 双端队列
		- 略
5. 栈和队列的应用
	- 栈在括号匹配中的应用
	- 栈在表达式求值的应用
		- 中缀表达式 前缀表达式 后缀表达式的相互转化
	- 栈的递归中的应用
		- 递归的效率并不是太高
			- 递归效率不高的原因是递归调用过程中包含很多重复的计算
		- 但递归的代码简单，容易理解
		- 通常需要借助栈来实现将递归算法转换为非递归算法
	- 队列在层次遍历
		- 二叉树的层次遍历
	- 队列在计算机系统中应用
		- 解决主机和外部设备之间速度不匹配的问题
		- 解决多用户引起的资源竞争问题
## 树和二叉树
### 树
1. 树是 n `(n >= 0)` 个结点的有限集合
	- `n == 0` 时为空树
	- 非空树满足以下几点要求
		1. 有且只有一个特殊的称为**根**的结点
		2. 当 `n > 1` 时, 其余结点为 m`(m > 0)` 个互不相交的有限集合, 其中每一个集合本身又是一根树，称为根节点的子树
	- 树是一种递归的数据结构
		1. 树的根结点没有前驱结点，除根结点外的所有结点有且只有一个前驱结点
		2. 树中所有结点可以有零个或者多个后继结点
	- 树中一个结点的子结点个数称为该结点的度
		- 数中结点的额最大度数称为树的度
	- 树的特性
		1. 树中的结点数 = 所有结点的度数 + 1
		2. 度为 m 的树中第 i 层上至多有 `m^(i-1)` 个结点`（i >= 1）`
		3. 高度为 h 的 m 叉树至多有 `(m^h - 1) / (m - 1)`个结点
		4. 具有 n 个结点的 m 叉树的最小高度为 `Math.ceil(log(n * (m - 1) + 1) / log(m))`
### 二叉树
1. 二叉树的特点是每个结点至多只有两颗子树
	- 即使树中结点只有一棵子树，也要区分是左子树还是右子树
	- 二叉树可以是空树
	- 二叉树是有序树，左右子树不可颠倒
2. 特殊的二叉树
	- 满二叉树
		- 高度为 h, 且含有 `2^h - 1` 个结点的二叉树称为满二叉树，即每一层结点都拉满
		- 叶子结点一定在最下层
		- 对于编号为 i 的结点，若有左孩子，则左孩子必为 `2i`; 若有右孩子，右孩子必为 `2i + 1`, 若有双亲，则必为`Math.floor(i/2)`
	- 完全二叉树
		- 若 `i <= Math.floor(i/2)` 则 i 必为分支结点，反之为叶子结点
		- 若有度为 1 的结点，则只可能有一个，且该结点只有左孩子而无右孩子
		- 按层序编号，一旦出现 i 结点为叶子结点或只有左孩子，则编号大于 i 的结点均为叶子结点
	- 二叉排序树
		- 左子树上所有结点的关键字均小于根结点的关键字，右子树上所有结点的关键字均大于根结点的关键字
		- 左子树和右子树又分别是一棵二叉排序树
	- 平衡二叉树
		- 树上任一结点的左子树和右子树的深度之差不超过 1