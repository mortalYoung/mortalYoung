# 数据结构快速复习

## 栈、队列和数组
### 栈
1. 栈（Stack）只允许在一端进行插入或删除操作的线性表
    - 线性表
    - 操作受限的线性表 只允许在一端插入和删除
    - 可操作的一端叫栈顶，不可操作的一端叫栈底
    - 没有任何元素的空表叫空栈
    - 操作特性为后进先出（Last In First Out, LIFO）
2. 栈的基本操作包括
    - InitStack(&S): 初始化空栈 S
    - StackEmpty(S): 判断一个栈是否为空
    - Push(&S, x): 进栈，若 S 未满，则 x 进栈成为新栈顶
        - 进栈时，指针先加一，再入栈
    - Pop(&S, &x): 出栈，若 S 非空，则弹出栈顶元素，用 x 返回
        - 出栈时，先出栈，再指针减一
    - GetTop(S, &x): 读取栈顶元素，若 S 非空，则用 x 返回栈顶元素
    - DestoryStack(&S): 销毁栈，释放栈的储存空间
3. 栈的顺序结构
    - 连续的内存地址分配
    - 共享栈
        - 利用栈底位置不变的特性，两个顺序栈共享一个数据空间
        - 两个栈的栈底分别位于空间两端，指针向空间中间移动
        - 当两个指针相连的时候，则栈满
4. 栈的链式存储结构
    - 链栈
    - 操作与链表类型
### 队列
1. 队列（Queue）只允许在表的一端进行插入，而在表的另一端进行删除
    - 线性表
    - 操作受限的线性表
    - 插入元素叫入队或进队，删除元素叫出队或离队
    - 入队的一端叫队尾，出队的一端叫队头
    - 不含任何元素的空表叫空队列
2. 队列的基本操作
    - 略
3. 队列的顺序结构
    - front 指针和 rear 指针分别指向队头和队尾
    - 初始化时 `front == rear == 0` 即队空的判断
    - 进队：先送值到队尾，再 `rear += 1`
    - 出队：先取队头元素，再 `front += 1`
    - 队满条件判断：不可使用 `rear == MaxSize` 因为队列存在 “上溢出”
    - 由于存在上溢出的缺点，所以有一种队列叫**循环队列**
        - 即把存储队列元素的表**从逻辑**上视为一个环
        - 当队首指针 `front == MaxSize - 1` 后, 再前进一个位置就归零
        - 初始化：`front == rear == 0`
        - 队首指针进一操作：`front = (front + 1) % MaxSize`
        - 队尾指针进一操作：`rear = (rear + 1) % MaxSize`
        - 队列长度：`(rear + MaxSize - front) % MaxSize`
        - 队空判断：`front == rear`
        - 队满同样是 `front == rear`
            - 牺牲一个单元来区分队空和队满
                - 队满：`(rear + 1) % MaxSize == front`
                - 队空：`front == rear`
                - 队列长度：`(rear - front + MaxSize) % MaxSize`
            - 在定义类型的时候新增表示元素个数的数据类型
                ```C++
                #define MaxSize 50
                typedef struct {
                    ElemType data[MaxSize];
                    int front;rear;
                    int length;
                } SqQueue
                ```
            - 在定义类型的时候增设 tag 来区分，总的来说和上一个方法类似
4. 队列的链式存储
	- 链队列实际上就是带有头尾指针的单链表
	- 当 `Q.front == null && Q.rear == null` 时，链队列为空
	- 适合用于数据元素变动比较大的情形，不存在队列满且溢出的问题
	- 双端队列
		- 略
5. 栈和队列的应用
	- 栈在括号匹配中的应用
	- 栈在表达式求值的应用
		- 中缀表达式 前缀表达式 后缀表达式的相互转化
	- 栈的递归中的应用
		- 递归的效率并不是太高
			- 递归效率不高的原因是递归调用过程中包含很多重复的计算
		- 但递归的代码简单，容易理解
		- 通常需要借助栈来实现将递归算法转换为非递归算法
	- 队列在层次遍历
		- 二叉树的层次遍历
	- 队列在计算机系统中应用
		- 解决主机和外部设备之间速度不匹配的问题
		- 解决多用户引起的资源竞争问题
## 树和二叉树
### 树
1. 树是 n `(n >= 0)` 个结点的有限集合
	- `n == 0` 时为空树
	- 非空树满足以下几点要求
		1. 有且只有一个特殊的称为**根**的结点
		2. 当 `n > 1` 时, 其余结点为 m`(m > 0)` 个互不相交的有限集合, 其中每一个集合本身又是一根树，称为根节点的子树
	- 树是一种递归的数据结构
		1. 树的根结点没有前驱结点，除根结点外的所有结点有且只有一个前驱结点
		2. 树中所有结点可以有零个或者多个后继结点
	- 树中一个结点的子结点个数称为该结点的度
		- 数中结点的额最大度数称为树的度
	- 树的特性
		1. 树中的结点数 = 所有结点的度数 + 1
		2. 度为 m 的树中第 i 层上至多有 `m^(i-1)` 个结点`（i >= 1）`
		3. 高度为 h 的 m 叉树至多有 `(m^h - 1) / (m - 1)`个结点
		4. 具有 n 个结点的 m 叉树的最小高度为 `Math.ceil(log(n * (m - 1) + 1) / log(m))`
### 二叉树
1. 二叉树的特点是每个结点至多只有两颗子树
	- 即使树中结点只有一棵子树，也要区分是左子树还是右子树
	- 二叉树可以是空树
	- 二叉树是有序树，左右子树不可颠倒
2. 特殊的二叉树
	- 满二叉树
		- 高度为 h, 且含有 `2^h - 1` 个结点的二叉树称为满二叉树，即每一层结点都拉满
		- 叶子结点一定在最下层
		- 对于编号为 i 的结点，若有左孩子，则左孩子必为 `2i`; 若有右孩子，右孩子必为 `2i + 1`, 若有双亲，则必为`Math.floor(i/2)`
	- 完全二叉树
		- 若 `i <= Math.floor(i/2)` 则 i 必为分支结点，反之为叶子结点
		- 若有度为 1 的结点，则只可能有一个，且该结点只有左孩子而无右孩子
		- 按层序编号，一旦出现 i 结点为叶子结点或只有左孩子，则编号大于 i 的结点均为叶子结点
	- 二叉排序树
		- 左子树上所有结点的关键字均小于根结点的关键字，右子树上所有结点的关键字均大于根结点的关键字
		- 左子树和右子树又分别是一棵二叉排序树
	- 平衡二叉树
		- 树上任一结点的左子树和右子树的深度之差不超过 1
3. 主要特性
    - 非空二叉树的叶子结点数等于度为 2 的结点数加 1 ，即 `n0 = n2 + 1`;
        - 证明： 
            ```js
                n0 + n1 + n2 = n1 + 2 * n2 + 1
            =>  n0 = n2 + 1
            ```
    - 非空二叉树上第 k 层有 `2^(k + 1)` 个结点
    - 高度为 h 的二叉树至多有 `2^h - 1` 个结点（即树的特性 3.）
    - 具有 n 个结点的二叉树的最小高度为 `Math.ceil(log(n + 1) / log(2))`（即树的特性 4.）
4. 二叉树的顺序存储和链式存储结构
    - 完全二叉树和满二叉树采用顺序存储比较合适，最坏情况下，会形成稀疏矩阵极大的浪费存储空间
    - 在含有 n 个结点的二叉链表中，含有 `n + 1` 个空链域
5. 二叉树的遍历
    - 先序遍历（NLR）
        ```js
            function preOrder(T: BiTree) {
                if(T != null){
                    visit(T);   // 访问根节点
                    preOrder(T.lchild); // 遍历左子树
                    preOrder(T.rchild); // 遍历右子树
                }
            }
        ```
    - 中序遍历（LNR）
        ```js
            function InOrder(T: BiTree) {
                if(T != null){
                    InOrder(T.lchild); // 遍历左子树
                    visit(T);   // 访问根节点
                    InOrder(T.rchild); // 遍历右子树
                }
            }
        ```
    - 后序遍历（LRN）
        ```js
            function PostOrder(T: BiTree) {
                if(T != null){
                    PostOrder(T.lchild); // 遍历左子树
                    PostOrder(T.rchild); // 遍历右子树
                    visit(T);   // 访问根节点
                }
            }
        ```
    - 以上三种遍历的时间复杂度都是 `O(n)`，空间复杂度都为 `O(n)`
    - 层次遍历
        ```js
            function LevelOrder(T: BiTree) {
                const Q = InitQueue(); // 初始化辅助队列
                let p: BiTree;
                Q.EnQueue(T);   // 根节点入队
                while(!Q.isEmpty()) {
                    const p = Q.DeQueue(); // 队头元素出队
                    visit(p);
                    if(p.lchild != null){
                        Q.EnQueue(p.lchild);
                    }
                    if(p.rchild != null){
                        Q.EnQueue(p.rchild);
                    }
                }
            }
        ```
    - 先序 + 中序；中序 + 后序； 中序 + 层序；均可确定唯一的二叉树
        - 先序 + 后序不可
    
6. 树的存储结构
    - 双亲表示法
        - 即定义的数据结构中有一个 parent 属性用于指向双亲位置域
        ```ts
            type PTNode = {
                data: any;
                parent: int; // 双亲位置区域
            }
            interface PTree {
                n: int; //结点数
                nodes: PTNode[];
            }

            const BiTree: PTree = {
                n: 3;
                nodes: [{
                    data: "A",
                    parent: -1
                }, {
                    data: "B",
                    parent: 0
                }, {
                    data: "C",
                    parent: 0
                }]
            }
        ```
        - 显然，该结构较容易获得某一结点的双亲结点，但并不容易获得某一结点的孩子结点
    - 孩子表示法
        - 将每个结点的孩子结点用单链表链接起来，具有 n 个结点的树具有 n 个孩子链表
        ```bash
            0 A -> [B] -> [C]
            1 B
            2 C
        ```
        - 显然此结构很容易获得某一结点的孩子结点，但寻找双亲结点就很麻烦。如果需要寻找 `C` 结点的双亲结点，则需要从遍历每一个孩子链表
    - 孩子兄弟表示法
        - 又称二叉树表示法，即借助二叉链表来作为树的存储结构
        ```js
            interface CSNode {
                data: any;
                firstchild: CSNode;
                nextsibling: CSNode;
            }
        ```
        - 由于是二叉链表，是单向链表，所以在寻找双亲结点上比较麻烦，所以再增加一个 `parent` 属性指向父节点则可以解决这个问题
7. 森林与二叉树的转化
    - (前置：大纲没提到，但是下面需要用到)树转二叉树
        - 将树结构用孩子兄弟表示法（二叉树表示法）表示后，得到的物理结构与二叉树的二叉链表表示法相同
        - 因此树转二叉树只需要用孩子兄弟表示法表示即可
        - 由于孩子兄弟表示法的右子树是兄弟结点，而根节点没有兄弟结点，故树转二叉树后的二叉树必没有右子树
    - 森林转二叉树：
        - 把森林中的每一棵树转为二叉树（此处用到树转二叉树）
        - 将第一棵树的根作为二叉树的根
        - 将第一棵树的左子树作为二叉树根的左子树
        - 将第二棵树作为二叉树的右子树
        - 将第三棵树作为二叉树根的右子树的右子树
        - 以此类推
    - 二叉树转森林：
        - 与上面反向即可
        - 二叉树转换为树或森林是唯一的
8. 树和森林的遍历
    - 树的遍历：
        - 先根遍历
            - 先访问根结点，再从左到右顺序遍历根节点的每棵子树
            - 访问顺序与这棵树对应的二叉树的先序遍历顺序相同
        - 后根遍历
            - 从左到右顺序遍历根节点的每棵子树，再访问根节点
            - 访问顺序与这棵树对应的二叉树的中序遍历顺序相同
        - 层次遍历
            - 和二叉树的层次遍历思想基本相同
    - 森林的遍历
        - 先序遍历：
            - 访问第一棵树的根结点
            - 先序遍历第一棵树的子树
            - 先序遍历除了第一棵树以外的剩下树构成的森林
        - 中序遍历：
            - 中序遍历第一棵树的子树
            - 访问第一棵树的根节点
            - 中序遍历除了第一棵树以外的剩下树构成的森林

## 树和二叉树的应用
### 二叉排序树
- 二叉排序树（BST），也称二叉查找树
    - 特性如下：
        - 若左子树非空，左子树上所有的结点关键字值都小于根节点的关键字值
        - 若右子树非空，右子树上所有的节点关键字值都大于根节点的关键字值
        - 左右子树本身也分别是一棵二叉排序树
    - 二叉排序树的查找
        ```js
            function BST_Search(T: BiTree, key: any) {
                let Tree = T;
                let p = null;
                while(Tree != null && key != Tree.data){
                    p = Tree;
                    if(key < T.data) {
                        Tree = Tree.lchild;
                    }else{
                        T = T.rchild;
                    }
                }
                return p;
            }
        ```
    - 二叉排序树的插入
        - 思路如下：
            - 若二叉排序树为空，则直接插入
            - 若关键字 k 小于根结点的关键字，则插入左子树
            - 若关键字 k 大于根结点的关键字，则插入右子树
        - 代码略
        - 插入的新结点一定是某个叶结点
    - 构造二叉排序树
        - 依次输入数据元素，不断插入到适当位置上的过程
    - 二叉排序树的删除
        - 分为三种情况
            1. 被删除结点为叶子结点，没有左右子树，则直接删除
            2. 被删除结点只有左子树或只有右子树，则用被删除结点的子树代替被删除结点的位置
            3. 被删除结点有左右两棵子树，令被删除结点的直接后继（指中序遍历时，被删除结点的下一个结点）替代被删除结点的位置，然后删除直接后继结点（转换为 1. 2. 的情况）
    - 查找效率
        - 考虑高度为 h 的二叉排序树
            - 插入操作和删除操作的操作时间都是 `O(h)`
            - 最坏情况下，输入的数据元素是有序的，则形成倾斜的单支树，此时性能显著变坏
### 堆结构
- 略
### 哈夫曼树
- 在含有 n 个带权叶子结点的二叉树中，其中 WLP 最小的二叉树称为哈夫曼树，也称最优二叉树
- 哈夫曼树的构造
    1. 首先将 n 个结点视作 n 个二叉树
    2. 从 n 个二叉树中选择两棵根结点权值最小的树作为新结点的左右子树，新结点的根权值则为左右子树权值之和
    3. 将新结点与剩下的 n - 2 个结点混合得到 n - 1 棵二叉树
    4. 重复 2. 和 3. 操作 直至只剩下一棵树
- 哈夫曼编码
    - 略