# 数据结构快速复习

## 栈、队列和数组
### 栈
1. 栈（Stack）只允许在一端进行插入或删除操作的线性表
    - 线性表
    - 操作受限的线性表 只允许在一端插入和删除
    - 可操作的一端叫栈顶，不可操作的一端叫栈底
    - 没有任何元素的空表叫空栈
    - 操作特性为后进先出（Last In First Out, LIFO）
2. 栈的基本操作包括
    - InitStack(&S): 初始化空栈 S
    - StackEmpty(S): 判断一个栈是否为空
    - Push(&S, x): 进栈，若 S 未满，则 x 进栈成为新栈顶
        - 进栈时，指针先加一，再入栈
    - Pop(&S, &x): 出栈，若 S 非空，则弹出栈顶元素，用 x 返回
        - 出栈时，先出栈，再指针减一
    - GetTop(S, &x): 读取栈顶元素，若 S 非空，则用 x 返回栈顶元素
    - DestoryStack(&S): 销毁栈，释放栈的储存空间
3. 栈的顺序结构
    - 连续的内存地址分配
    - 共享栈
        - 利用栈底位置不变的特性，两个顺序栈共享一个数据空间
        - 两个栈的栈底分别位于空间两端，指针向空间中间移动
        - 当两个指针相连的时候，则栈满
4. 栈的链式存储结构
    - 链栈
    - 操作与链表类型
### 队列
1. 队列（Queue）只允许在表的一端进行插入，而在表的另一端进行删除
    - 线性表
    - 操作受限的线性表
    - 插入元素叫入队或进队，删除元素叫出队或离队
    - 入队的一端叫队尾，出队的一端叫队头
    - 不含任何元素的空表叫空队列
2. 队列的基本操作
    - 略
3. 队列的顺序结构
    - front 指针和 rear 指针分别指向队头和队尾
    - 初始化时 `front == rear == 0` 即队空的判断
    - 进队：先送值到队尾，再 `rear += 1`
    - 出队：先取队头元素，再 `front += 1`
    - 队满条件判断：不可使用 `rear == MaxSize` 因为队列存在 “上溢出”
    - 由于存在上溢出的缺点，所以有一种队列叫**循环队列**
        - 即把存储队列元素的表**从逻辑**上视为一个环
        - 当队首指针 `front == MaxSize - 1` 后, 再前进一个位置就归零
        - 初始化：`front == rear == 0`
        - 队首指针进一操作：`front = (front + 1) % MaxSize`
        - 队尾指针进一操作：`rear = (rear + 1) % MaxSize`
        - 队列长度：`(rear + MaxSize - front) % MaxSize`
        - 队空判断：`front == rear`
        - 队满同样是 `front == rear`
            - 牺牲一个单元来区分队空和队满
                - 队满：`(rear + 1) % MaxSize == front`
                - 队空：`front == rear`
                - 队列长度：`(rear - front + MaxSize) % MaxSize`
            - 在定义类型的时候新增表示元素个数的数据类型
                ```C++
                #define MaxSize 50
                typedef struct {
                    ElemType data[MaxSize];
                    int front;rear;
                    int length;
                } SqQueue
                ```
            - 在定义类型的时候增设 tag 来区分，总的来说和上一个方法类似
4. 队列的链式存储
	- 链队列实际上就是带有头尾指针的单链表
	- 当 `Q.front == null && Q.rear == null` 时，链队列为空
	- 适合用于数据元素变动比较大的情形，不存在队列满且溢出的问题
	- 双端队列
		- 略
5. 栈和队列的应用
	- 栈在括号匹配中的应用
	- 栈在表达式求值的应用
		- 中缀表达式 前缀表达式 后缀表达式的相互转化
	- 栈的递归中的应用
		- 递归的效率并不是太高
			- 递归效率不高的原因是递归调用过程中包含很多重复的计算
		- 但递归的代码简单，容易理解
		- 通常需要借助栈来实现将递归算法转换为非递归算法
	- 队列在层次遍历
		- 二叉树的层次遍历
	- 队列在计算机系统中应用
		- 解决主机和外部设备之间速度不匹配的问题
		- 解决多用户引起的资源竞争问题
## 树和二叉树
### 树
1. 树是 n `(n >= 0)` 个结点的有限集合
	- `n == 0` 时为空树
	- 非空树满足以下几点要求
		1. 有且只有一个特殊的称为**根**的结点
		2. 当 `n > 1` 时, 其余结点为 m`(m > 0)` 个互不相交的有限集合, 其中每一个集合本身又是一根树，称为根节点的子树
	- 树是一种递归的数据结构
		1. 树的根结点没有前驱结点，除根结点外的所有结点有且只有一个前驱结点
		2. 树中所有结点可以有零个或者多个后继结点
	- 树中一个结点的子结点个数称为该结点的度
		- 数中结点的额最大度数称为树的度
	- 树的特性
		1. 树中的结点数 = 所有结点的度数 + 1
		2. 度为 m 的树中第 i 层上至多有 `m^(i-1)` 个结点`（i >= 1）`
		3. 高度为 h 的 m 叉树至多有 `(m^h - 1) / (m - 1)`个结点
		4. 具有 n 个结点的 m 叉树的最小高度为 `Math.ceil(log(n * (m - 1) + 1) / log(m))`
### 二叉树
1. 二叉树的特点是每个结点至多只有两颗子树
	- 即使树中结点只有一棵子树，也要区分是左子树还是右子树
	- 二叉树可以是空树
	- 二叉树是有序树，左右子树不可颠倒
2. 特殊的二叉树
	- 满二叉树
		- 高度为 h, 且含有 `2^h - 1` 个结点的二叉树称为满二叉树，即每一层结点都拉满
		- 叶子结点一定在最下层
		- 对于编号为 i 的结点，若有左孩子，则左孩子必为 `2i`; 若有右孩子，右孩子必为 `2i + 1`, 若有双亲，则必为`Math.floor(i/2)`
	- 完全二叉树
		- 若 `i <= Math.floor(i/2)` 则 i 必为分支结点，反之为叶子结点
		- 若有度为 1 的结点，则只可能有一个，且该结点只有左孩子而无右孩子
		- 按层序编号，一旦出现 i 结点为叶子结点或只有左孩子，则编号大于 i 的结点均为叶子结点
	- 二叉排序树
		- 左子树上所有结点的关键字均小于根结点的关键字，右子树上所有结点的关键字均大于根结点的关键字
		- 左子树和右子树又分别是一棵二叉排序树
	- 平衡二叉树
		- 树上任一结点的左子树和右子树的深度之差不超过 1
3. 主要特性
    - 非空二叉树的叶子结点数等于度为 2 的结点数加 1 ，即 `n0 = n2 + 1`;
        - 证明： 
            ```js
                n0 + n1 + n2 = n1 + 2 * n2 + 1
            =>  n0 = n2 + 1
            ```
    - 非空二叉树上第 k 层有 `2^(k + 1)` 个结点
    - 高度为 h 的二叉树至多有 `2^h - 1` 个结点（即树的特性 3.）
    - 具有 n 个结点的二叉树的最小高度为 `Math.ceil(log(n + 1) / log(2))`（即树的特性 4.）
4. 二叉树的顺序存储和链式存储结构
    - 完全二叉树和满二叉树采用顺序存储比较合适，最坏情况下，会形成稀疏矩阵极大的浪费存储空间
    - 在含有 n 个结点的二叉链表中，含有 `n + 1` 个空链域
5. 二叉树的遍历
    - 先序遍历（NLR）
        ```js
            function preOrder(T: BiTree) {
                if(T != null){
                    visit(T);   // 访问根节点
                    preOrder(T.lchild); // 遍历左子树
                    preOrder(T.rchild); // 遍历右子树
                }
            }
        ```
    - 中序遍历（LNR）
        ```js
            function InOrder(T: BiTree) {
                if(T != null){
                    InOrder(T.lchild); // 遍历左子树
                    visit(T);   // 访问根节点
                    InOrder(T.rchild); // 遍历右子树
                }
            }
        ```
    - 后序遍历（LRN）
        ```js
            function PostOrder(T: BiTree) {
                if(T != null){
                    PostOrder(T.lchild); // 遍历左子树
                    PostOrder(T.rchild); // 遍历右子树
                    visit(T);   // 访问根节点
                }
            }
        ```
    - 以上三种遍历的时间复杂度都是 `O(n)`，空间复杂度都为 `O(n)`
    - 层次遍历
        ```js
            function LevelOrder(T: BiTree) {
                const Q = InitQueue(); // 初始化辅助队列
                let p: BiTree;
                Q.EnQueue(T);   // 根节点入队
                while(!Q.isEmpty()) {
                    const p = Q.DeQueue(); // 队头元素出队
                    visit(p);
                    if(p.lchild != null){
                        Q.EnQueue(p.lchild);
                    }
                    if(p.rchild != null){
                        Q.EnQueue(p.rchild);
                    }
                }
            }
        ```
    - 先序 + 中序；中序 + 后序； 中序 + 层序；均可确定唯一的二叉树
        - 先序 + 后序不可
    
6. 树的存储结构
    - 双亲表示法
        - 即定义的数据结构中有一个 parent 属性用于指向双亲位置域
        ```ts
            type PTNode = {
                data: any;
                parent: int; // 双亲位置区域
            }
            interface PTree {
                n: int; //结点数
                nodes: PTNode[];
            }

            const BiTree: PTree = {
                n: 3;
                nodes: [{
                    data: "A",
                    parent: -1
                }, {
                    data: "B",
                    parent: 0
                }, {
                    data: "C",
                    parent: 0
                }]
            }
        ```
        - 显然，该结构较容易获得某一结点的双亲结点，但并不容易获得某一结点的孩子结点
    - 孩子表示法
        - 将每个结点的孩子结点用单链表链接起来，具有 n 个结点的树具有 n 个孩子链表
        ```bash
            0 A -> [B] -> [C]
            1 B
            2 C
        ```
        - 显然此结构很容易获得某一结点的孩子结点，但寻找双亲结点就很麻烦。如果需要寻找 `C` 结点的双亲结点，则需要从遍历每一个孩子链表
    - 孩子兄弟表示法
        - 又称二叉树表示法，即借助二叉链表来作为树的存储结构
        ```js
            interface CSNode {
                data: any;
                firstchild: CSNode;
                nextsibling: CSNode;
            }
        ```
        - 由于是二叉链表，是单向链表，所以在寻找双亲结点上比较麻烦，所以再增加一个 `parent` 属性指向父节点则可以解决这个问题
7. 森林与二叉树的转化
    - (前置：大纲没提到，但是下面需要用到)树转二叉树
        - 将树结构用孩子兄弟表示法（二叉树表示法）表示后，得到的物理结构与二叉树的二叉链表表示法相同
        - 因此树转二叉树只需要用孩子兄弟表示法表示即可
        - 由于孩子兄弟表示法的右子树是兄弟结点，而根节点没有兄弟结点，故树转二叉树后的二叉树必没有右子树
    - 森林转二叉树：
        - 把森林中的每一棵树转为二叉树（此处用到树转二叉树）
        - 将第一棵树的根作为二叉树的根
        - 将第一棵树的左子树作为二叉树根的左子树
        - 将第二棵树作为二叉树的右子树
        - 将第三棵树作为二叉树根的右子树的右子树
        - 以此类推
    - 二叉树转森林：
        - 与上面反向即可
        - 二叉树转换为树或森林是唯一的
8. 树和森林的遍历
    - 树的遍历：
        - 先根遍历
            - 先访问根结点，再从左到右顺序遍历根节点的每棵子树
            - 访问顺序与这棵树对应的二叉树的先序遍历顺序相同
        - 后根遍历
            - 从左到右顺序遍历根节点的每棵子树，再访问根节点
            - 访问顺序与这棵树对应的二叉树的中序遍历顺序相同
        - 层次遍历
            - 和二叉树的层次遍历思想基本相同
    - 森林的遍历
        - 先序遍历：
            - 访问第一棵树的根结点
            - 先序遍历第一棵树的子树
            - 先序遍历除了第一棵树以外的剩下树构成的森林
        - 中序遍历：
            - 中序遍历第一棵树的子树
            - 访问第一棵树的根节点
            - 中序遍历除了第一棵树以外的剩下树构成的森林

## 树和二叉树的应用
### 二叉排序树
- 二叉排序树（BST），也称二叉查找树
    - 特性如下：
        - 若左子树非空，左子树上所有的结点关键字值都小于根节点的关键字值
        - 若右子树非空，右子树上所有的节点关键字值都大于根节点的关键字值
        - 左右子树本身也分别是一棵二叉排序树
    - 二叉排序树的查找
        ```js
            function BST_Search(T: BiTree, key: any) {
                let Tree = T;
                let p = null;
                while(Tree != null && key != Tree.data){
                    p = Tree;
                    if(key < T.data) {
                        Tree = Tree.lchild;
                    }else{
                        T = T.rchild;
                    }
                }
                return p;
            }
        ```
    - 二叉排序树的插入
        - 思路如下：
            - 若二叉排序树为空，则直接插入
            - 若关键字 k 小于根结点的关键字，则插入左子树
            - 若关键字 k 大于根结点的关键字，则插入右子树
        - 代码略
        - 插入的新结点一定是某个叶结点
    - 构造二叉排序树
        - 依次输入数据元素，不断插入到适当位置上的过程
    - 二叉排序树的删除
        - 分为三种情况
            1. 被删除结点为叶子结点，没有左右子树，则直接删除
            2. 被删除结点只有左子树或只有右子树，则用被删除结点的子树代替被删除结点的位置
            3. 被删除结点有左右两棵子树，令被删除结点的直接后继（指中序遍历时，被删除结点的下一个结点）替代被删除结点的位置，然后删除直接后继结点（转换为 1. 2. 的情况）
    - 查找效率
        - 考虑高度为 h 的二叉排序树
            - 插入操作和删除操作的操作时间都是 `O(h)`
            - 最坏情况下，输入的数据元素是有序的，则形成倾斜的单支树，此时性能显著变坏
### 堆结构
- 略
### 哈夫曼树
- 在含有 n 个带权叶子结点的二叉树中，其中 WLP 最小的二叉树称为哈夫曼树，也称最优二叉树
- 哈夫曼树的构造
    1. 首先将 n 个结点视作 n 个二叉树
    2. 从 n 个二叉树中选择两棵根结点权值最小的树作为新结点的左右子树，新结点的根权值则为左右子树权值之和
    3. 将新结点与剩下的 n - 2 个结点混合得到 n - 1 棵二叉树
    4. 重复 2. 和 3. 操作 直至只剩下一棵树
- 哈夫曼编码
    - 略
## 图
### 图的基本概念
- 图 Graph 由顶点集 Vertex 和边集 Edge 组成，记为 `G = (V,E)`
    - 其中，`V(G)` 表示图 G 中顶点的有限非空集
    - `E(G)` 表示图 G 中顶点之间的关系集合
    - 若 `V = {v1, v2, v3, v4}`, 则用 `|V|` 来表示图 G 中的顶点个数，也称图 G 的阶
    - `|E|` 表示图 G 中的边的条数
    - 注：线性表可以为空表，树可以是空树，但是图不可以是空图。即 V 一定非空，而 E 可以为空
- 基本概念
    - 有向图：
        - 若 E 为有向边的有限集合时，则图 G 为有向图
    - 无向图：
        - 若 E 为无向边的有限集合时，则图 G 为无向图
    - 简单图：
        - 一个图满足
            1. 不存在重复边
            2. 不存在顶点到自身的边

            则称之为简单图
    - 多重图：
        - 若图 G 中某两个结点之间的边数多于一条，有允许顶点通过同一条边和自己关联，则图 G 为多重图
    - 完全图（简单完全图）：
        - 无向图中，若任意两个顶点之间都存在边，则称之为无向完全图。含有 n 个顶点的无向完全图有 `n * (n - 1) / 2` 条边
        - 有向图中，若任意两个顶点之间都存在方向相反的弧，则称之为有向完全图。含有 n 个顶点的有向完全图有 `n * (n - 1)` 条边
    - 子图
        - 若两个图 `G1 = (V1, E1)` 和 `G2 = (V2, E2)`，若 V2 是 V1 的子集，且 E2 是 E1 的子集，则称 G2 为 G1 的子集
    - 连通、连通图、连通分量
        - 无向图中，若顶点 v 到顶点 w 有路径存在，则称 v 和 w 是连通的。
        - 若图 G 中任意两个顶点都是连通的，则称之为连通图。
        - 极大连通子图即要求连通子图包含其所有的边；最小连通子图即既保持图连通又要使得边数最少的子图
        - 无向图中的极大连通子图称之为连通分量
    - 强连通图、强连通分量
        - 有向图中，若顶点 v 到 顶点 w 和顶点 w 到顶点 v 之间都有路径，则称这两个点是强连通的。
        - 若图中任意两个点都是强连通的，则称之为强连通图
        - 有向图中的极大强连通子图称之为有向图的强连通分量
    - 生成树、生成森林
        - 连通树的生成树是包含图中全部顶点的一个极小连通子图
    - 顶点的度，入度，出度
        - 每个顶点的度定义为以该顶点为一个端点的边的个数
        - 对于无向图，顶点 v 的度是指依附于该顶点的边的条数，记为 `TD(v)`
        - 无向图的全部顶点的度的和等于边数的两倍，即 `sum(TD(v)) === 2 * e`;
        - 对于有向图，顶点 v 的度分为入度和出度
        - 入度是以该顶点为终点的有向边的条数，记为 `ID(v)`，出度相反，记为 `OD(v)`;
        - 有向图的全部顶点的入度之和和出度之和相等，并且等于边数，即 `sum(ID(v)) === sum(OD(v)) === e`
    - 路径、路径长度和回路
        - 若一个图有 n 个顶点，并且有大于 `n - 1` 条边，则此图必有环
### 图的存储
- 邻接矩阵法（顺序存储结构）
    - 用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息
    - 结点数为 n 的图的邻接矩阵 A 是 `n*n` 的
    - 
        ```js
        if(A[i][j] is exist) {
            A[i][j] = 1;
        } else {
            A[i][j] = 0;
        }
        ```
    - 对于带权图而言
        ```js
        if(A[i][j] is exist) {
            A[i][j] = Wij; // 该边的权值
        } else {
            A[i][j] = 0; // or ∞
        }
        ```
    - 具有以下特点：
        - 无向图的邻接矩阵一定是一个对称矩阵（并且唯一）
        - 对于无向图，邻接矩阵的第 i 行非零元素的个数正好是第 i 个顶点的度 `TD(vi)`
        - 对于有向图，第 i 行为出度，第 j 列为入度
        - 容易确认任意两个顶点之间是否有边相连，但是较难确认图中有多少条边
        - 稠密图适合用邻接矩阵
        - **设图 G 的邻接矩阵为 A，`A^n` 元素的 `A^n[i][j]` 等于由顶点 i 到顶点 j 的长度为 n 的路径的数目**
- 邻接表法
    - 结合了顺序存储和链式存储方法，大大减少了当图为稀疏图时浪费存储空间
    - 定义两个数据类型，分别为顶点表和边表、
        ```js
        interface 顶点表 {
            data: any; // 顶点域
            firstarc: 边表; // 边表头指针
        }
        interface 边表 {
            adjvex: any; // 邻接点域
            nextarc: 边表; // 指针域
        }
        ```
        - 顶点表用于存储图 G 中的顶点数据信息以及边表头指针
        - 边表用于存储图 G 中依附于某一个顶点的全部边的信息
    - 图的邻接表并不唯一，因为各个边结点的连接次序可以是任意的，主要取决于建立邻接表的算法以及边的输入次序
- 十字链表法
    - 用于**有向图**的一种链式存储结构
    - 定义两个数据类型，分别为弧结点和顶点结点
    - 由于有向图存在入度和出度，故定点节点存在 `firstin`, `firstout` 两个弧结点指针域
    - 弧结点包含大量信息，依次为：`tailvex`, `headvex`, `hlink`, `tlink`, `info` 分别表示弧尾位置，弧头位置，弧尾相同的下一条弧，弧头相同的下一条弧以及该弧结点的相关信息
- 邻接多重表法
    - 用于**无向图**的另一种链式存储结构
    - 同样定义两个数据类型，分别为边结点和顶点结点
    - 顶点结点与邻接表法一致
    - 边结点包含大量信息，依次为：`mark`, `ivex`, `ilink`, `jverx`, `jlink`, `info`, 分别表示标志域（用于判断该条边是否被搜索过），该边依附的一个结点 i，下一条依附于 i 的边，该边依附的另一个结点 j，下一条依附于 j 的边以及该边结点的相关信息
### 图的遍历
- 广度优先搜索（BFS）
    - 基本思想：从起始顶点 v 出发，先访问 v 结点，依次访问 v 的各个**未访问过的**邻接顶点 `w1,w2,w3,...,wi`,然后依次访问 `w1,w2,w3,...,wi` 的所有未访问过的邻接顶点；以此类推，直到图中所有顶点都被访问过为止
    - 由于需要借助一个数组 `visited[]` 来标记当前结点是否被访问过，故空间复杂度为 `O(V)`, 时间复杂度为 `O(V^2)`
    - 借助 BFS 来求解 Dijkstra 单源最短路径算法
- 深度优先搜索（DFS）
    - 基本思想：尽可能 “深” 地搜索一个图
    - DFS 的空间复杂度为 `O(V)` 时间复杂度为 `O(V+E)`
### 图的基本应用
- 最小生成树
    - 设 R 为 G 的所有生成树的集合，若 T 为 R 中边的权值之和最小的那棵树，则称 T 为 G 的最小生成树
    - 性质如下：
        - 不唯一
        - 虽然树形不唯一，但是权值之和唯一
        - 最小生成树的边数必定为顶点数减 1
        ```js
         function generic_MST(G){
            let T = null;
            while(T 不是一棵生成树){
                /*
                * 1. 找到代价边
                * 2. 加入 T 不会产生回路
                */
                const edge = function getEdeg(G)
                /* 把代价边加入 T 里 */
                T = T && edge
            }
         }
        ```
    - Prim 算法
        - 略
    - Kruskal 算法
        - 略
- 最短路径
    - 单源最短路径，即求图中某一顶点到其他各顶点的最短路径，用 Dijkstra 算法求解
        - 算法：略
    - 求每一对顶点间的最短路径，用 Floyd-Warshall 算法求解
        - 算法：略
- 拓扑排序
    - 在图论中，由一个有向无环图（DAG）的顶点组成的序列，且满足以下条件时，称为该图的一个拓扑排序
        1. 每个顶点有且仅有出现一次
        2. 若顶点 A 排在顶点 B 的前面，则在图中不存在从 B 到 A 的路径
## 动态查找
- AVL 树
    - 保证任意结点的左右子树高度差的绝对值不超过 1 的二叉树称作平衡二叉树（Balanced Binary Tree)
    - 插入分为 4 种情况：
        - LL 平衡，在结点 A 的左孩子（L）的左子树（L）插入新结点，解法：略
        - RR 平衡，在结点 A 的右孩子的右子树插入新结点，解法：略
        - LR 平衡，在结点 A 的左孩子的右子树插入新结点，解法：略
        - RL 平衡，在结点 A 的右孩子的左子树插入新结点，解法：略
- 散列表
    - 略

